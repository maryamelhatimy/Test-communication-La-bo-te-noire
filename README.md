# Introduction
Dans les syst√®mes embarqu√©s modernes, la collecte et l‚Äôanalyse de donn√©es en temps r√©el sont essentielles pour le suivi et la s√©curit√© des √©quipements, notamment dans des domaines critiques comme l‚Äôautomobile, l‚Äôaviation ou le ferroviaire. S‚Äôinspirant du fonctionnement des bo√Ætes noires utilis√©es dans ces industries, ce projet a pour objectif de concevoir un syst√®me embarqu√© capable d‚Äôenregistrer et de transmettre en temps r√©el des donn√©es de mouvement (vitesse et orientation) √† l‚Äôaide d‚Äôun capteur inertiel. Les informations sont ensuite visualis√©es sur une station de contr√¥le via un √©cran LCD.
Ce projet s‚Äôinscrit dans le cadre du Tekbot Robotics Challenge et fait appel √† plusieurs comp√©tences majeures : programmation directe des microcontr√¥leurs ATmega328P sans utiliser de carte Arduino, communication via le protocole I2C, conception de circuits imprim√©s avec KiCAD, r√©alisation d‚Äôun bo√Ætier cubique de 7 cm, int√©gration mat√©rielle sur veroboard ou PCB, ainsi que la conception d‚Äôune alimentation sp√©cifique.
# Sommaire

- [cahier des charges ](#Cahier-des-charges)
- [Sch√©ma synoptique](#Sch√©ma-synoptique)
- [R√©alisation du PCB](#R√©alisation-du-PCB)
- [Description fonctionnelle des diff√©rents blocs du syst√®me](#Description-fonctionnelle-des-diff√©rents-blocs-du-syst√®me)
  
# Cahier des charges

## Objectifs fonctionnels
- Lire les donn√©es de vitesse et d‚Äôorientation √† l‚Äôaide du MPU6050
- Utiliser le microcontr√¥leur ATmega328P sans carte Arduino
- Concevoir un circuit imprim√© (PCB) et une alimentation autonome
- Transmettre les donn√©es √† une station de contr√¥le via I2C
- Afficher les donn√©es sur un √©cran LCD en mode 4 bits

## Contraintes techniques
- Le cube doit mesurer 7x7x7 cm, avec une face ouverte pour voir le circuit
- Le microcontr√¥leur du cube agit en **ma√Ætre I2C**
- Le microcontr√¥leur de la station agit en **esclave I2C**
- Alimentation externe obligatoire, hors du cube
- Sch√©ma et PCB r√©alis√©s avec **KiCad**

## Mat√©riel utilis√©

- [ATmega328P](https://ww1.microchip.com/downloads/en/DeviceDoc/Atmel-7810-Automotive-Microcontrollers-ATmega328P_Datasheet.pdf) √ó2  
- [MPU6050](https://invensense.tdk.com/wp-content/uploads/2015/02/MPU-6000-Datasheet1.pdf)  
- [LCD 16x2 (mode 4 bits)](https://www.gotronic.fr/pj2-sbc-lcd16x2-fr-1441.pdf?srsltid=AfmBOopmg8VyH8PQXxRcqE7GEvoyRwGRHeKVU9ZsKwGmKu13oZXhPhaJ)  
- Alimentation

  
# Sch√©ma synoptique
Ce syst√®me embarqu√© est compos√© de deux unit√©s : une bo√Æte noire et une station de contr√¥le, connect√©es via le bus I2C. La bo√Æte noire comprend un capteur MPU6050 qui d√©tecte les mouvements de la main et envoie les donn√©es √† un microcontr√¥leur ATmega328P configur√© en ma√Ætre. Celui-ci traite les donn√©es et les transmet √† la station de contr√¥le, o√π un autre ATmega328P, configur√© en esclave, les re√ßoit. Les informations sont ensuite affich√©es sur un √©cran LCD. Chaque unit√© est aliment√©e s√©par√©ment par une source de 5V.

![sch√©ma synoptique](https://github.com/user-attachments/assets/8b703337-a753-49e2-947b-a988aeb19c89)

# Description fonctionnelle des diff√©rents blocs du syst√®me
## Bloc d‚Äôalimentation
## 1. Fonction principale
Ce bloc a pour objectif de fournir une tension continue et stable de 5V n√©cessaire au fonctionnement des diff√©rents composants √©lectroniques du syst√®me, notamment le capteur MPU6050, les microcontr√¥leurs ATmega328P et l'√©cran LCD.
## 2. Fonctionnement
On utilise trois batteries de Li-Ion 3,7V rechargeables mont√©es en s√©rie pour obtenir environ 12V.  
Le r√©gulateur L7805 re√ßoit ce 12V en entr√©e (Vin) et fournit du 5V en sortie (Vout).  
Deux condensateurs (330nF et 100nF) sont utilis√©s pour stabiliser la tension et filtrer les parasites.
- 330nF √† l‚Äôentr√©e
- 100nF √† la sortie

üìå Le sch√©ma suivant illustre ce montage :
![image](https://github.com/user-attachments/assets/690d4b70-85dd-4cbb-bff8-a1c31e7033fd)

## Bloc d‚Äôentr√©e(dans la boite noire)

Nous avons choisi le capteur MPU6050 parce qu‚Äôil int√®gre un acc√©l√©rom√®tre et un gyroscope dans un seul composant. Cela permet de mesurer les mouvements et les rotations de la main avec pr√©cision. Il est facile √† utiliser gr√¢ce au protocole I2C, et il fonctionne bien avec le microcontr√¥leur ATmega328P. En plus, il est peu co√ªteux et largement utilis√© dans les projets embarqu√©s. D‚Äôautres capteurs peuvent faire un travail similaire, comme le MPU9250 (qui ajoute un magn√©tom√®tre), le LSM6DS3 (plus r√©cent et plus √©conome), ou le ADXL34

![image](https://github.com/user-attachments/assets/2c989400-0c29-46dc-907c-dcd7208a431b)
## Bloc de commande(dans la boite noire)
Avant d‚Äôint√©grer le microcontr√¥leur ATmega328P dans la bo√Æte noire et de concevoir le circuit imprim√©, nous avons d‚Äôabord r√©alis√© plusieurs essais pour nous familiariser avec ce composant, car nous avions l‚Äôhabitude d‚Äôutiliser des cartes Arduino.
Nous avons donc simul√© des circuits simples sur Proteus, notamment un montage avec l‚ÄôATmega328P, un bouton poussoir, un relais et une lampe 12V. Le principe √©tait le suivant : lorsqu‚Äôon appuie sur le bouton, le relais active l‚Äôalimentation de la lampe, qui s‚Äôallume. Cette √©tape nous a permis de comprendre le fonctionnement du microcontr√¥leur et son pilotage direct sans carte Arduino.

# La communication I2C
Ce document constitue une pr√©sentation d√©taill√©e et approfondie du protocole **I2C (Inter-Integrated Circuit)**, qui est un standard de communication s√©rie synchrone tr√®s r√©pandu dans l‚Äô√©lectronique embarqu√©e. Ce protocole facilite l‚Äô√©change d‚Äôinformations entre un ou plusieurs ma√Ætres et plusieurs p√©riph√©riques esclaves en utilisant seulement deux fils, simplifiant ainsi les connexions mat√©rielles tout en assurant une communication fiable et efficace.  


# Sommaire

- [üìò Introduction](#-introduction)
- [‚öôÔ∏è Principe de fonctionnement](#-principe-de-fonctionnement)  
  - [üîπ Prise de contr√¥le du bus](#-prise-de-contr√¥le-du-bus)  
  - [üîπ Transmission d'un octet](#-transmission-dun-octet)  
  - [üîπ Transmission d'une adresse](#-transmission-dune-adresse)  
  - [üîπ √âcriture d'une donn√©e](#-√©criture-dune-donn√©e)  
  - [üîπ Arbitration](#-arbitration)
  - [üîπ Clock Stretching](#-clock-stretching)
- [üì° Communication I2C entre MPU6050 et ATmega328P](#-communication-i2c-entre-mpu6050-et-atmega328p)  
  - [üîπ Fonctionnement de la liaison I2C](#-fonctionnement-de-la-liaison-i2c)
  - [üîπ Envoi des commandes et r√©ception des donn√©es](#-envoi-des-commandes-et-reception-des-donnees)


---

## üìò Introduction
Dans les syst√®mes √©lectroniques modernes, les microcontr√¥leurs, capteurs, m√©moires, convertisseurs de donn√©es et autres circuits int√©gr√©s doivent souvent √©changer des informations entre eux.
Pour assurer une transmission fiable, rapide et structur√©e des donn√©es, on utilise des protocoles de communication (c'est un ensemble de r√®gles et de conventions d√©finissant la mani√®re dont les donn√©es sont √©chang√©es entre les diff√©rents composants d‚Äôun syst√®me).
On distingue deux types principaux :  
**-Parall√®le** : rapide, mais n√©cessite plusieurs fils.  
**-S√©rie** : plus simple, utilise moins de fils, adapt√©e aux syst√®mes embarqu√©s.  
Parmi les protocoles s√©rie les plus connus : **UART,SPI,I2C,CAN,LIN...**    
Parmi les protocoles s√©rie les plus utilis√©s, **le protocole I2C** se distingue par sa simplicit√©, son faible co√ªt de mise en ≈ìuvre, et sa capacit√© √† connecter de nombreux p√©riph√©riques avec seulement deux lignes. Voyons maintenant de plus pr√®s son fonctionnement.  
üëâ Voyons maintenant de plus pr√®s son fonctionnement.


---

## ‚öôÔ∏è Principe de fonctionnement
[Protocole I2C](https://fr.wikipedia.org/wiki/I2C) (Inter-Integrated Circuit), d√©velopp√© par Philips (aujourd‚Äôhui NXP) dans les ann√©es 1980, est un standard mondial pour la communication s√©rie entre circuits int√©gr√©s, surtout dans les syst√®mes embarqu√©s. Il utilise un bus bidirectionnel √† deux fils : SDA pour les donn√©es et SCL pour l‚Äôhorloge, permettant √† plusieurs p√©riph√©riques de partager le m√™me canal tout en g√©rant pr√©cis√©ment l‚Äôacc√®s.  
Contrairement √† des protocoles comme SPI, I2C minimise le nombre de connexions n√©cessaires, ce qui simplifie le routage sur circuit imprim√© et r√©duit les co√ªts.   Ce protocole est largement utilis√© dans des domaines vari√©s : automobile, domotique, informatique, etc.  
I2C fonctionne selon un mod√®le.[ma√Ætre-esclave](https://www.ionos.fr/digitalguide/serveur/know-how/le-principe-master/slave): un ou plusieurs ma√Ætres contr√¥lent la communication, et les esclaves r√©pondent aux requ√™tes. Chaque communication commence par une condition **Start**, suivie de **l‚Äôadresse de l‚Äôesclave** et d‚Äôun bit de direction (lecture/√©criture). Les donn√©es sont ensuite √©chang√©es octet par octet, chaque octet √©tant confirm√© par **un bit d‚Äôacquittement**(ACK). La communication se termine par une condition **Stop**, qui lib√®re le bus.  
Techniquement, I2C utilise des lignes ouvertes (open-drain) : les dispositifs ne peuvent que tirer les lignes vers le bas, tandis que des r√©sistances pull-up maintiennent le niveau haut par d√©faut. Cela √©vite les conflits, notamment en mode multi-ma√Ætres.  
Enfin, I2C offre une grande flexibilit√© en termes de vitesse, du mode standard (100 kHz) au mode rapide (jusqu‚Äô√† 3,4 MHz) et au-del√† dans certaines variantes propri√©taires.  
![communication-I2C](https://github.com/user-attachments/assets/42f1202c-0ec3-4e69-a15c-abace28aff09) 


---

### üîπ Prise de contr√¥le du bus

La prise de contr√¥le du bus par un ma√Ætre d√©bute par une **condition Start (S)**, qui est un √©v√©nement distinctif sur le bus. Cette condition correspond √† une transition sur la ligne SDA de l‚Äô√©tat haut √† l‚Äô√©tat bas, alors que la ligne SCL est maintenue √† l‚Äô√©tat haut. Cette s√©quence particuli√®re est d√©tect√©e par tous les p√©riph√©riques connect√©s au bus, qui entrent alors en mode √©coute, pr√™ts √† recevoir des donn√©es.  

La condition Start joue un r√¥le fondamental : elle marque l‚Äôexclusivit√© du ma√Ætre sur le bus, ce qui √©vite les collisions ou l‚Äôinterf√©rence avec d‚Äôautres ma√Ætres √©ventuels. Elle sert aussi de synchronisation initiale √† la transmission de donn√©es, en assurant que tous les appareils sont synchronis√©s sur le d√©but de la communication.  

Les r√©sistances pull-up sur les lignes SDA et SCL maintiennent ces lignes √† un √©tat logique haut par d√©faut, garantissant ainsi que le bus est en repos quand aucune communication n‚Äôa lieu.

## üñºÔ∏è Image : BUS I2C 
![Bus-i2c](https://github.com/user-attachments/assets/56dc1d36-e7e6-44f3-b15a-36ae52d9d87d)  
## üñºÔ∏è Image : condition start
![start-condition](https://github.com/user-attachments/assets/c1bdf777-61d8-4f95-a602-330b61cba147) 

---

### üîπ Transmission d'un octet

La transmission des donn√©es sur le bus I2C s‚Äôeffectue par octets (8 bits). Chaque bit est transmis s√©quentiellement, en commen√ßant par le bit le plus significatif (MSB).  

Le protocole impose que chaque bit soit plac√© sur la ligne SDA pendant que la ligne SCL est √† l‚Äô√©tat bas. Ensuite, la ligne SCL passe √† l‚Äô√©tat haut, moment o√π le r√©cepteur lit la valeur pr√©sente sur la ligne SDA. Lorsque la ligne SCL redescend √† l‚Äô√©tat bas, l‚Äô√©metteur peut placer le bit suivant sur SDA, et ainsi de suite.  

Apr√®s l‚Äôenvoi des 8 bits d‚Äôun octet, la ligne SDA est lib√©r√©e pendant le 9e cycle d‚Äôhorloge. C‚Äôest alors au r√©cepteur de signaler par un bit d‚Äôacquittement (ACK) s‚Äôil a correctement re√ßu l‚Äôoctet, en tirant la ligne SDA √† l‚Äô√©tat bas. S‚Äôil ne tire pas SDA √† z√©ro, un bit de non-acquittement (NACK) est d√©tect√©, ce qui indique que la communication doit √™tre interrompue ou qu‚Äôune erreur s‚Äôest produite.  

Ce m√©canisme d‚Äô**ACK/NACK** est crucial car il assure la fiabilit√© des transmissions, permettant au ma√Ætre de savoir si l‚Äôesclave est disponible et pr√™t √† recevoir ou envoyer des donn√©es.

---

### üîπ Transmission d'une adresse

Apr√®s la condition Start, le ma√Ætre envoie un octet d‚Äôadresse pour identifier l‚Äôesclave avec lequel il souhaite communiquer. L‚Äôadresse est g√©n√©ralement cod√©e sur 7 bits, suivis d‚Äôun bit R/W indiquant si la transaction sera une lecture ou une √©criture.  

Le protocole pr√©voit aussi une extension 10 bits pour les r√©seaux comportant un grand nombre de p√©riph√©riques, mais cette extension est moins fr√©quemment utilis√©e.  

Tous les p√©riph√©riques esclaves surveillent le bus et comparent l‚Äôadresse re√ßue avec leur propre adresse. Celui qui reconna√Æt son adresse r√©pond alors par un bit ACK en tirant la ligne SDA √† l‚Äô√©tat bas pendant le 9e bit. Les autres esclaves restent silencieux jusqu‚Äô√† la prochaine s√©quence.  

Cette √©tape est essentielle car elle garantit que seules les communications destin√©es √† un p√©riph√©rique sp√©cifique sont trait√©es, √©vitant ainsi toute interf√©rence entre plusieurs p√©riph√©riques sur le m√™me bus.
## üñºÔ∏è Image : transmission d'une adresse  
![transmission_d'une_adresse](https://github.com/user-attachments/assets/426c9eaf-1dc3-4bfc-bb9d-1b4b468bced7)

---

### üîπ √âcriture d'une donn√©e

Une fois l‚Äôadresse reconnue par l‚Äôesclave, la phase de transfert des donn√©es peut commencer. Le ma√Ætre transmet alors les octets de donn√©es √† l‚Äôesclave, chaque octet √©tant suivi d‚Äôun bit ACK envoy√© par l‚Äôesclave pour confirmer la bonne r√©ception.  

Le protocole permet d‚Äôenvoyer autant d‚Äôoctets que n√©cessaire dans une m√™me communication, ce qui permet des transferts efficaces et continus.  

Pour terminer la communication, le ma√Ætre g√©n√®re une condition **Stop (P)**, qui correspond √† une transition de la ligne SDA de l‚Äô√©tat bas √† l‚Äô√©tat haut alors que la ligne SCL est haute. Cette s√©quence indique √† tous les p√©riph√©riques que la transmission est termin√©e et que le bus est lib√©r√© pour une autre communication.  

Il existe √©galement une condition **Restart**, qui est une condition Start g√©n√©r√©e sans condition Stop pr√©alable, permettant de cha√Æner plusieurs op√©rations sur le m√™me bus sans interruption.  
## üñºÔ∏è Image : transmission d'une donnee
![transmission-d'une-donnee](https://github.com/user-attachments/assets/51e00c84-0cf6-4005-928a-f2d0413f72a8)  
## üñºÔ∏è Image : condition stop
![stop-condition](https://github.com/user-attachments/assets/a3bcc978-09d5-408d-a788-68827986eedc) 

---

### üîπ Arbitration

Le protocole I2C est con√ßu pour supporter un mode multi-ma√Ætres, o√π plusieurs ma√Ætres peuvent tenter d‚Äôacc√©der au bus simultan√©ment. Pour √©viter les conflits, un m√©canisme d‚Äôarbitrage est mis en place.  

Lorsqu‚Äôun ma√Ætre commence √† transmettre, il surveille la ligne SDA et la compare avec ce qu‚Äôil souhaite envoyer. Si un ma√Ætre d√©tecte que la ligne SDA est forc√©e √† l‚Äô√©tat bas par un autre ma√Ætre alors qu‚Äôil tente de la maintenir haute, il comprend qu‚Äôil a perdu l‚Äôarbitrage et abandonne imm√©diatement la transmission, laissant le bus libre au ma√Ætre dominant.  

Ce m√©canisme garantit qu‚Äôaucune collision √©lectrique ne se produit sur le bus et que seule une source transmet √† un instant donn√©. C‚Äôest une des forces du protocole I2C, qui permet une coexistence harmonieuse de plusieurs ma√Ætres sur un m√™me bus.
## üñºÔ∏è Image : arbitrage
![arbitrage](https://github.com/user-attachments/assets/2b7e7f8a-e0f6-46b2-9b76-5f87cdfb8dcb)



### üîπ Clock Stretching

Le clock stretching est une fonctionnalit√© du protocole I2C qui permet √† un esclave de ralentir temporairement la communication lorsqu‚Äôil n‚Äôest pas pr√™t √† envoyer ou recevoir des donn√©es. Cela se fait en gardant la ligne SCL √† l‚Äô√©tat bas (LOW), emp√™chant ainsi le ma√Ætre de continuer √† envoyer des impulsions d‚Äôhorloge. Une fois que l‚Äôesclave est pr√™t, il lib√®re la ligne SCL, permettant au ma√Ætre de reprendre la transmission. Cette technique est utile, par exemple, lorsque le capteur a besoin de plus de temps pour traiter ou pr√©parer les donn√©es. Le ma√Ætre doit respecter cet √©tirement d‚Äôhorloge pour √©viter des erreurs de communication.  

## üñºÔ∏è Image : clock stretching
![clock streatching](https://github.com/user-attachments/assets/1149606a-e454-484b-9eb4-7030ac5e0d8f)  
---
## üì° Communication I2C entre MPU6050 et ATmega328P
Dans notre projet, le microcontr√¥leur **ATmega328P** communique avec le capteur **MPU6050** √† l‚Äôaide du protocole **I2C**. Ce protocole permet de transmettre les donn√©es d‚Äôacc√©l√©ration et de rotation via deux fils (`SDA` et `SCL`). Le **MPU6050** agit comme **esclave**, et l‚Äô**ATmega328P** comme **ma√Ætre**.

---

### üîπ Fonctionnement de la liaison I2C

La connexion mat√©rielle entre le MPU6050 et l‚ÄôATmega328P s‚Äôeffectue via le protocole I2C (Inter-Integrated Circuit), qui utilise deux lignes de communication :   
- SDA (Serial Data Line) : ligne bidirectionnelle pour l‚Äô√©change des donn√©es, connect√©e √† la broche PC4 de l‚ÄôATmega328P.    
- SCL (Serial Clock Line) : ligne d‚Äôhorloge g√©n√©r√©e par le ma√Ætre, connect√©e √† la broche PC5 de l‚ÄôATmega328P.

Sur le bus I2C, le dispositif qui initie la communication est appel√© ma√Ætre, tandis que celui qui r√©pond s‚Äôappelle esclave. Dans notre cas :    
L‚ÄôATmega328P joue le r√¥le de ma√Ætre, c‚Äôest lui qui contr√¥le le bus, g√©n√®re l‚Äôhorloge, et initie les √©changes.    
Le MPU6050 est l‚Äôesclave, il attend que le ma√Ætre lui demande des donn√©es sp√©cifiques.    
Le ma√Ætre d√©marre la communication en envoyant une adresse unique correspondant √† l‚Äôesclave (ici l‚Äôadresse I2C du MPU6050, g√©n√©ralement 0x68), suivie d‚Äôune commande indiquant quel registre ou donn√©e il souhaite lire.  
                          
| ATmega328P | MPU6050 |
|------------|---------|
| PC4 (SDA)    | SDA     |
| PC5 (SCL)    | SCL     |
| VCC        | 5V  |
| GND        | GND     |
| üîß Pull-up | Recommand√© : 4.7kŒ© sur SDA et SCL |  

## üñºÔ∏è Image : liaison-i2c-entre-mpu6050-et-atmega328p
![liaison-entre-mpu6050-atmega328p](https://github.com/user-attachments/assets/f277cd9e-e71a-4ea2-91e9-050bcb0050a0)
 
---

### üîπ Envoi des commandes et r√©ception des donn√©es

La communication suit ce processus :  
- Le ma√Ætre (ATmega328P) commence par envoyer une commande au MPU6050, qui consiste √† sp√©cifier l‚Äôadresse du registre interne dont il souhaite lire la valeur. Par exemple, pour lire l‚Äôacc√©l√©ration sur l‚Äôaxe X, il envoie l‚Äôadresse du registre ACCEL_XOUT_H.  
- Cette commande est envoy√©e via le bus I2C sous forme d‚Äôune trame contenant l‚Äôadresse de l‚Äôesclave, suivie de l‚Äôadresse du registre cibl√©.  
- Une fois la commande re√ßue, le MPU6050 pr√©pare la donn√©e correspondante et la transmet d√®s que le ma√Ætre la demande.  
- Le ma√Ætre r√©cup√®re alors la ou les valeurs envoy√©es par le capteur, g√©n√©ralement sur plusieurs octets, qu‚Äôil traite ensuite pour en extraire l‚Äôinformation de mouvement (acc√©l√©ration, rotation, temp√©rature).
  
[voir le datasheet du MPU6050](https://www.alldatasheet.com/datasheet-pdf/download/1132807/TDK/MPU-6050.html)    

 # R√©alisation du PCB

## Cr√©ation du sch√©ma √©lectronique
- Conception du sch√©ma int√©grant le microcontr√¥leur ATmega328P, le capteur MPU-6050 et les connecteurs.
[voir le sch√©ma √©lectronique](Images.md#Cr√©ation-du-sch√©ma-√©lectronique)

## Affectation des empreintes (footprints)
- Attribution des empreintes physiques correspondant aux composants.
[voir Affectation des empreintes](Images.md#Affectation-des-empreintes)

## Cr√©ation de la carte PCB (implantation)
- Placement des empreintes des composants sur le circuit imprim√©.

  ![Cr√©ation de la carte PCB](https://github.com/user-attachments/assets/ea794759-0ee5-4ad1-9845-91bff85d9f4c)

## R√©organisation des composants
- Ajustement de la disposition pour optimiser l‚Äôespace et faciliter le routage.

![R√©organisation des composants](https://github.com/user-attachments/assets/159148ee-3c07-492a-8ed8-c2e2e21f3099)

## Routage des pistes
- Tra√ßage des pistes √©lectriques reliant les composants.
  
![ Routage des pistes](https://github.com/user-attachments/assets/14889db7-c03d-41f7-9225-8cdfcd50c843)

## D√©finition des contours du PCB (Edge Cuts)
- D√©limitation de la forme finale et des dimensions de la carte.
  
![ D√©finition des contours du PCB](https://github.com/user-attachments/assets/3df37061-8004-4fdc-8a90-1eaaaba42349)

## Visualisation 3D du PCB
- Contr√¥le visuel du circuit imprim√© en trois dimensions avant fabrication.
  
![ Visualisation 3D du PCB](https://github.com/user-attachments/assets/29374317-7dc3-43e4-95ee-a7a15d3b6c9a)


